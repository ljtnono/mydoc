# MySQL是怎样运行的（从根上儿理解MySQL）读书笔记

## 第一章

### 1.1 MySQL的客户端/服务器架构

我们常见的软件基本上分为两类，一类是以浏览器/服务器为架构的BS结构，还有一类是以客户端/服务器为架构的CS结构。MySQL是后者。我们日常使用MySQL的场景可以简单的分为以下几个步骤：
1. 启动MySQL服务器程序。
2. 启动MySQL客户端程序，并连接到服务器程序。
3. 在客户端程序中输入命令语句，并将其作为请求发送给服务器程序。服务器程序在收到这些请求后，会根据请求的内容来操作具体的数据，并将结果返回给客户端。

### 1.5 客户端与服务器连接的过程

我们现在已经知道如何启动MySQL的服务器程序，以及如何启动客户端程序来连接到这个服务器程序。运行中的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器发送请求并得到响应的过程本质上是一个进程间通信的过程！MySQL支持下面几种客户端进程和服务进程的通信方式：

* **TCP/IP网络通信方式**。
* **命名管道和共享内存（windows）**。
* **UNIX域套接字方式**。

#### 1.5.3 UNIX域套接字

**如果服务器进程和客户端进程都运行在操作系统为类UNIX的同一台机器上，则可以使用UNIX域套接字进行进程间通信。如果在启动客户端程序时没有指定主机名，或者指定的主机名为localhost，又或者指定了--protocol=socket的启动参数，那么服务器程序和客户端程序之间就可以通过UNIX域套接字进行通信了。**

MySQL服务器程序默认坚挺的UNIX域套接字文件名称为`/tmp/mysql.sock`，客户端程序也默认连接到这个UNIX域套接字文件名称。如果想改变这个默认的名称，可以在启动服务器程序时指定socket参数，就像下面这样：

```bash
mysqld --socket=/tmp/a.txt
```

这样服务器在启动后便会监听/tmp/a.txt。在服务器改变了默认的UNIX域套接字文件名称后，如果客户端程序想通过UNIX域套接字进行通信，也需要显示的指定连接的UNIX域套接字文件名称，就像下面这样：

```bash
mysql -hlocalhost -uroot --socket=/tmp/a.txt
```

### 1.6 服务器处理客户端请求

以查询请求为例，一个请求的大致过程如图1-1所示：

从图1-1中可以看出，服务器程序在处理来自客户端的查询请求时，大致需要分为3部分：**连接管理**、**解析与优化**、**存储引擎**。

#### 1.6.1 连接管理

MySQL服务端的连接管理大致可以总结为以下几点：

* 客户端进程可以通过TCP/IP、命名管道或共享内存、UNIX域套接字等几种方式与服务器进程建立连接。

* 客户端发起连接时，需要携带主机信息、用户名、密码等信息，服务器程序会对客户端程序提供的这些信息进行认证。如果认证失败，服务器程序会拒绝连接。另外，如果客户端程序和服务器程序不运行在一台计算机上，可以通过TLS协议对连接进行加密，从而保证数据传输的安全性。
* MySQL服务器会对客户端连接进行缓存，减少不停创建连接的性能损耗（应该是线程池技术）。

#### 1.6.2 解析与优化

解析与优化主要分为**查询缓存**、**语法解析**和**查询优化**几个部分。

1. **查询缓存**

   MySQL会将每个查询请求进行缓存，如果下一次有同样的请求过来，那么会直接从缓存中查找结果。不过缓存会在以下情况下失效：

   * 表产生了更新操作`INSERT`、`UPDATE`、`DELETE`、`TRUNCATE TABLE`、`ALTER TABLE`、`DROP TABLE`或`DROP DATABASE`都会导致该表所有查询缓存失效。
   * 查询请求有任何一个字符不相同则不会命中缓存。

   由于以上情况导致查询缓存有些鸡肋，所以MySQL在5.7.20开始，不推荐使用查询缓存，并在MySQL8.0中直接删除。

2. **语法解析**

   如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本，所以MySQL服务器程序首先要对这段文本进行分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到MySQL服务器内部使用的一些数据结构上。

   > ​	从本质上来说，这个从指定的文本中提取出需要的信息算是一个编译过程，涉及词法解析、语法分析、语义分析等阶段。这些问题比较复杂，大家只要了解在处理请求的过程中需要这个步骤就好了。

3. **查询优化**

   在语法解析之后，服务器程序获得了需要的信息，比如要查询的表和列是哪些、搜索条件是什么等。但光有这些是不够的，因为我们写的MySQL语句执行起来效率可能并不是很高，MySQL的优化程序会对我们的语句做一些优化，如**外连接转换为内连接**、**表达式简化**、**子查询转为连接查询等**一堆东西。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引执行查询，以及表之间的连接顺序是啥样，等等。我们可以使用**EXPLAIN**语句来查看某个语句的执行计划。

#### 1.6.3 存储引擎

到服务器程序完成了查询优化为止，还没有真正地去访问真实的表中数据（在查询优化期间可能访问表中少量数据，在讨论查询优化的章节中我们会详细唠叨）。MySQL服务器把数据的存储和提取操作都封装到了一个名为存储引擎的模块中。我们知道，表是由一行一行的记录组成的，但只是一个逻辑上的概念。在物理上如何表示记录，怎么从表中读取数据，以及怎么把数据写入具体的物理存储器上，都是存储引擎负责的事情。为了实现不同的功能，MySQL提供了各式各样的存储引擎，不同存储引擎管理的表可能有不同的存储结构，采用的存取算法也可能不同。

为了方便管理，人们把MySQL服务器处理请求的过程简单地划分为server层和存储引擎层。连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存取的功能划分为server层的功能，存取真实数据的功能划分为存储引擎层的功能。各种不同的存储引擎为server层提供统一的调用接口，其中包含了几十个不同用途的底层函数，比如“读取索引第一条记录”，“读取索引下一条记录”，“插入记录”等。

所以在server层完成了查询优化后，只需要按照生成的执行计划调用底层存储引擎提供的接口获取到数据后返回给客户端就好了。不过需要注意的一点是，server层和存储引擎层交互时，一般是以记录为单位的。以SELECT语句为例，server层根据执行计划先向存储引擎层取一条记录，然后判断是否符合WHERE条件；如果符合，就发送给客户端，否则跳过该记录，然后继续向存储引擎索要下一条记录；依此类推。

> ​	server层在判断某条记录符合要求之后，其实是先将其发送到一个缓冲区，待到该缓冲区满了，才向客户端发送真正的记录。该缓冲区大小由系统变量net_buffer_length控制。

### 1.9 总结

MySQL采用客户端/服务器架构，用户通过客户端程序发送增删改查请求，服务器程序收到请求后处理，并且把处理结果返回给客户端。

客户端进程和服务器进程在通信时采用下面几种方式：

* **TCP/IP**。
* **命名管道或共享内存（windows）**。
* **UNIX域套接字**。

以查询请求为例，服务器程序在处理客户端发送过来的请求时，大致分为几个部分。

* 连接管理：主要负责连接的建立与信息的认证。
* 解析与优化：主要进行查询缓存、语法解析、查询优化。
* 存储引擎：主要负责读取和写入底层表中的数据。

MySQL支持的存储引擎有好多种，它们的功能各有侧重，我们常用的就是InnoDB和MyISAM，其中InnoDB是服务器程序的默认存储引擎。存储引擎的一些常用用法如下所示：

* 查看当前服务器程序支持的存储引擎：

  ```mysql
  SHOW ENGINES;
  ```

* 创建表时指定表的存储引擎：

  ```mysql
  CREATE TABLE 表名 (
    建表语句
  ) ENGINE=存储引擎名称;
  ```

* 修改表的存储引擎：

  ```mysql
  ALTER TABLE 表名 ENGINE = 存储引擎名称;
  ```

## 第四章 从一条记录说起——InnoDB记录存储结构

### 4.2 InnoDB页简介

InnoDB是一个将表中的数据存储到磁盘上的存储引擎，即使我们关闭并重启服务器，数据还是存在。而真正处理数据的过程发生在内存中，所以需要把磁盘中的数据加载到内存中。 如果是处理写入或修改请求，还需要把内存中的内容刷新到磁盘上。 而我们知道读写磁盘的速度非常慢，与读写内存差了几个数量级。当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条地把记录从磁盘上读出来么？不，那样会慢死，InnoDB采取的方式是，将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位。InnoDB中页的大小一般为**16KB**。也就是在一般情况下，一次最少从磁盘中读取**16KB**的内容到内存中，一次最少把内存中的**16KB**内容刷新到磁盘中。

  * 可以通过`innodb_page_size`系统变量来控制innoDB页大小，这个变量只能在第一次出实话MySQL数据目录时之顶，之后就再也不能更改了。
  * 可以通过`SHOW VARIABLES LIKE '%innodb_page_size%'`命令来查看页大小。

### 4.3 InnoDB行格式

我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存放形式也被称为行格式或者记录格式。涉及InnoDB存储引擎的大叔到现在为止设计了
4种不同类型的行格式，分别是`COMPACT`、`REDUNDANT`、`DYNAMIC`、`COMPRESSED`。随着时间的推移，他们可能会设计出更多的行格式，但是
不管怎么变，这些行格式在原理上大体都是相同的。  

#### 4.3.1 指定行格式的语法

可以通过在创建表的时候定义该表的行格式：

```mysql
CREATE TABLE 表名(列信息) ROW_FORMAT=行格式名称;
```

例如：创建一个用户表，行格式使用COMPACT，字符编码为utf8mb4

```mysql
CREATE TABLE user(
    id INT PRIMARY KEY COMMENT 'id',
    username VARCHAR(40) NOT NULL COMMENT '用户名',
    passwd VARCHAR(64) NOT NULL COMMENT '密码' 
)ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC;
```

#### 4.3.2 COMPACT行格式

COMPACT行格式的示意图如下：  



从图中可以看出来，一条完整的记录其实可以分为额外信息和真实记录两部分。下面解释下这两部分都记录了些什么数据：  

1. 记录的额外信息

  这部分信息是服务器为了更好的管理记录不得不添加的额外信息。包括变长字段长度列表、NULL值列表和记录头信息。

  （1）变长字段长度列表

  我们知道mysql中有部分字段类型是不定长的，例如：`VARCHAR`、`TEXT`、`BLOB`、`LONGTEXT`，这些类型在COMPACT行格式中存储的信息包括：

    * 真正的数据内容。
    * 该数据所占用的字节数。

  在所有COMPACT行格式中，所有变长字段的真实数据占用的字节数都存放在记录的开头位置，从而形成一个变长字段长度列表，各变长字段的真实占用的字节数按照列的顺序`逆序存放`。

  （2）NULL值列表

  我们知道，一条记录中的某些列可能存储NULL值，如果把这些NULL值都放到记录的真实数据中存储会很占地方，所以COMPACT行格式把一条记录中值为NULL的列统一管理起来，存储到NULL值列表中。它的处理过程如下所示：

    1. 首先统计表中允许存储NULL的列有哪些。

       主键列以及使用`NOT NULL`修饰的列都是不可以存储NULL值的，所以在统计的时候不会把这些列算进去。比如表record_format__demo的3个列c1、 c3、c4都允许存储NULL值， c2列使用`NOT NULL`进行了修饰，不允许存储NULL值。

    2. 如果表中没有允许存储NULL值的列，则NULL值也就不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列。二进制位表示的意义如下：

       * **二进制位的值为1时，代表该列的值为NULL**;
       * **二进制位的值为0时，代表该列的值不为NULL**;

       因为表record_format_demo有三个值允许为NULL的列，所以这3个列和二进制位的关系如图4-4所示。

       **再一次强调，二进制位按照列的顺序逆序排列，所以第一个列c1和最后一个二进制位对应。**

    3. MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0，效果如图4-5所示。

       以此类推，如果一个表中有9个值允许为NULL的列，则这个记录的NULL值列表部分就需要2字节来表示了。

       知道了规则之后，我们再返回头看看表record_format_demo中两条记录中的NULL值列表应该怎么存储。因为只有c1、c3、c4这3个列允许存储NULL值，所以记录的NULL值列表处只需要一个字节。

       * 对于第一条记录来说，c1、c3、c4这3个列的值都不为NULL，所以它们对应的二进制位都是0，如图4-6所示。

         所以对于第一条记录的NULL值列表用十六进制表示就是0x00。

       * 对于第二条记录来说，c1、c3、c4这3个列中c3和c4的值都为NULL，所以这3个列对应的二进制位的情况如图4-7所示。

         所以第二条记录的NULL值列表用十六进制表示就是0x06。

         这两条记录在填充了NULL值列表后的示意图如图4-8所示。

  （3）记录头信息

  除了变长字段列表、NULL值列表之外，还有一个称之为记录头信息的部分。记录头信息由固定的5字节组成，用于描述记录的一些属性。5字节也就是40个二进制位，不同位代表不同的意思，如图4-9所示。

  

  另外，记录头信息的前4个位也被称为info bit。

  大家千万不要被这么多属性和陌生的概念吓着，这里把这些位代表的意思都写出来只是为了内容的完整性。没必要把它们的意思都记住，记住也没啥用，现在只需要看一遍混个脸熟，等之后用到这些属性的时候再回过头来看就好了。

  因为我们并不清楚这些属性的详细用法，所以这里就不分析各个属性值是怎么产生的了，之后我们会详细唠叨的，少安毋躁。现在直接看一下record_format_demo表中的两条记录的记录头信息分别是什么，如图4-10所示。

  

2. 记录的真实数据

   对于record_format_demo表来说，记录的真实数据除了c1、c2、c3、c4这几个我们自己定义的列的数据外，MySQL会为每个记录默认地添加一些列（也称为隐藏列），具体的列如表4-3所示。

   

   InnoDB表的主键生成策略：

   * 如果用户定义了主键，那么使用用户定义的主键
   * 如果用户没有定义主键，那么分为两种情况：
     1. 选择一个不允许存储NULL值的UNIQUE键作为主键
     2. 如果1不满足，则新增一个名为`DB_ROW_ID`的隐藏列作为主键

   因为表record_format_demo并没有定义主键，所以MySQL服务器会为每条记录增加上述的3个列。现在看一下加上记录的真实数据的两条记录长什么样子，如图4-11所示。

3. CHAR(M)列的存储格式

   前面讲到，在COMPACT行格式下，变长字段长度列表只是用来存放一条记录中各个变长字段的值占用的字节长度的。record_format_demo表的c1、c2、c4列的类型是VARCHAR(10)，也就是说c1、c2、c4都是变长字段；而c3列的类型是CHAR(10)，也就是说c3列不属于变长字段。所以会把一条记录的c1、c2、c4这3个列占用的字节长度逆序存到变长字段长度列表中，如果4-12所示。

   但这只是建立在我们的record_format_demo表采用的ascii字符集的情况下，这个字符集采用固定的一个字节来编码一个字符，是一个定长编码字符集。如果采用变长编码的字符集（也就是表示一个字符需要的字节数不确定，比如gbk表示一个字符要1~2字节、utf8表示一个字符要1~3字节等），虽然c3列的类型是CHAR(10)，但是设计COMPACT行格式的大叔规定，此时该列占用的字节数也会被存储到变长字段长度列表中。比如我们修改一下c3列的字符集：

   

   修改该字符集后，记录的变长字段长度列表也发生了变化，如图4-13所示。

   这就意味着，对于CHAR(M)类型的列来说，当列采用的是定长编码的字符集时，该列占用的字节数不会被加到变长字段长度列表；而如果采用变长编码的字符集时，该列暂用的

   

