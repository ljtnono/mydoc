# 常见垃圾回收算法详解

常见的垃圾回收算法可以分为两大类，一类是分代回收算法，一类是分区回收算法。

## 标记清除算法

最基础的垃圾回收算法，分为**两个阶段，标记和清除**。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。

在标记阶段，首先通过根节点标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。**如图**



由图可知，标记清除法的最大问题是可能产生内存空间碎片。

> **注意：标记清除法先通过根节点标记所有的可达对象，然后清除所有的不可达对象，完成垃圾回收。**


## 复制算法

复制算法的核心思想是：**将原有的内存空间分为两块，每次只使用其中一块，在进行垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。**

由此可知，复制算法有两个核心的优点。

1、复制算法在需要回收大部分对象的情况下效率很高，因为只需要复制很少的对象。
2、复制算法不会产生内存空间碎片。

虽然复制算法的优点明显，但是缺点却是可用的内存空间减半，这也是很难让人接受的。

**复制算法的工作示意图如下**


## 标记整理算法（标记压缩算法）

复制算法的高效性是建立在存活对象少，垃圾对象多的前提下。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本将很高。因此，基于老年代垃圾回收的特性，需要使用其他算法。

标记压缩法是一种老年代的回收算法。它在标记清除的基础上做了一些优化。和标记清除法一样，标记压缩法首先也需要从根节点开始，对所有可达对象做一次标记。但之后，它并不只是简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。然后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，性价比较高。

**标记压缩算法的工作示意图如下**



## 分区回收算法

略
