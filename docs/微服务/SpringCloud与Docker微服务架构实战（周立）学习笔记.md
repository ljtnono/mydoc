# SpringCloud与Docker微服务架构实战（周立）学习笔记

## 第一章微服务架构概述

学习重点：

1、单体架构和微服务架构的优缺点

2、微服务设计原则

3、微服务架构图

### 单体架构的优缺点

优点：

* 研发快
* 运维简单

缺点：

* 代码复杂性高
* 可靠性差
* 无法横向扩展
* 语言和技术栈受限

### 微服务架构的优缺点

优点：

* 易于开发和维护
* 技术栈不受限
* 按需伸缩

缺点：

* 运维要求高
* 分布式固有的复杂性
* 接口调整成本高

### 微服务设计原则

* 单一职责原则
* 服务自治原则
* 轻量通信机制
* 微服务粒度划分

### 微服务应用架构图

![简单微服务架构图](http://f.lingjiatong.cn:30090/rootelement/articleQuote/%E7%AE%80%E5%8D%95%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

## 第二章 SpringCloud

本章内容无关紧要，略过

## 第三章 开始使用SpringCloud实战微服务

学习重点：

1、了解怎么使用RestTemplate硬编码的方式调用服务

2、了解SpringBoot Actuator自带的端点和其作用

### RestTamplate硬编码调用微服务

#### 编写服务提供者

1、创建maven项目microservice-simple-provider-user,pom.xml文件内容如下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <artifactId>spring-boot-starter-parent</artifactId>
        <groupId>org.springframework.boot</groupId>
        <version>1.5.9.RELEASE</version>
    </parent>

    <groupId>com.springcloudanddockerbook</groupId>
    <artifactId>microservice-simple-consumer-movie</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Edgware.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

2、准备好建表语句，在项目的classpath下建立schema.sql文件，并添加以下内容

```sql
DROP TABLE user IF EXISTS;
CREATE TABLE user (
    id BIGINT GENERATED BY DEFAULT AS identity,
    username VARCHAR(40),
    name VARCHAR(20),
    age INT(3),
    balance decimal(10, 2),
    PRIMARY KEY (id)
)

```

3、准备几条数据，在项目的classpath下建立文件data.sql，并添加以下内容

```sql
INSERT INTO user(id, username, name, age, balance) VALUES(1, 'account1', '张三', 20, 100.00);
INSERT INTO user(id, username, name, age, balance) VALUES(2, 'account2', '李四', 28, 180.00);
INSERT INTO user(id, username, name, age, balance) VALUES(3, 'account3', '王五', 32, 280.00);
```

4、创建实体类

```java
@Data
@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @Column
    private String username;

    @Column
    private String name;

    @Column
    private Integer age;

    @Column
    private BigDecimal balance;
}
```

5、创建DAO

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
```

6、创建controller

```java
@RestController
public class UserController {

    @Autowired
    private UserRepository userRepository;


    @GetMapping("/{id}")
    public User findById(@PathVariable Long id) {
        User user = userRepository.findOne(id);
        return user;
    }

}
```

7、编写启动类

```java
@SpringBootApplication
public class ProviderUserApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProviderUserApplication.class, args);
    }

}
```

8、编写配置文件

```yml
server:
  port: 8000
spring:
  jpa:
    generate-ddl: false
    show-sql: true
    hibernate:
      ddl-auto: none
  datasource:
    platform: h2
    schema: classpath:schema.sql
    data: classpath:data.sql
logging:
  level:
    root: INFO
    org.hibernate: INFO
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE
    org.hibernate.type.descriptor.sql.BasicExtractor: TRACE
```

9、测试

```bash
# 访问http://localhost:8000/1
{
	"id": 1,
	"username": "account1",
	"name": "张三",
	"age": 20,
	"balance": 100
}
```

#### 编写服务消费者

1、创建项目microservice-simple-consumer-movie，pom.xml文件内容如下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <artifactId>spring-boot-starter-parent</artifactId>
        <groupId>org.springframework.boot</groupId>
        <version>1.5.9.RELEASE</version>
    </parent>

    <groupId>com.springcloudanddockerbook</groupId>
    <artifactId>microservice-simple-consumer-movie</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Edgware.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

2、创建用户实体类

```java
@Data
public class User {

    private Long id;

    private String username;

    private String name;

    private Integer age;
    
    private BigDecimal balance;
}
```

3、创建启动类

```java
@SpringBootApplication
public class ConsumerMovieApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConsumerMovieApplication.class, args);
    }

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

}
```

此处注入RestTemplate以方便controller调用服务提供者的接口

4、创建controller

```java
@RestController
public class MovieController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/user/{id}")
    public User findById(@PathVariable Long id)  {
        return restTemplate.getForObject("http://localhost:8000/" + id, User.class);
    }
}
```

5、编写配置文件

```yml
server:
  port: 8001
```

6、测试

```bash
# 访问http://localhost:8001/user/1
{
	"id": 1,
	"username": "account1",
	"name": "张三",
	"age": 20,
	"balance": 100
}
```

以上两个工程说明了可以使用RestTemplate进行微服务间的相互调用

### SpringBoot Actuator端点详解

SpringBoot Actuator是SpringBoot项目下的一个专门用于监控服务相关状态的模块，提供了很多端点来了解应用程序的运行状况

// TODO 待写

## 第四章 微服务注册与发现

学习重点：

1、了解服务发现组件的具备的功能和结构图

2、了解eureka原理，了解eureka的保护机制

3、搭建eureka高可用集群

4、了解eureka的Rest端点

5、eureka的自我保护模式

### 服务发现组件的作用

从第二章所示的例子来看，使用RestTemplate的方式进行服务间调用十分不方便，具体存在的问题有如下几点：

**1、适用场景有限**：如果服务提供者的网络地址（IP或者端口）发生了变化，就需要修改服务调用者的代码

**2、无法动态伸缩**：在生产环境中每个微服务一般都会部署多个实例，从而实现容灾和负载均衡。在微服务架构的系统中，还需要系统具备自动伸缩的能力，例如动态增减节点等。适用RestTemplate硬编码的方式无法适用这种需求

为了解决以上问题，需要一个服务发现组件，至少具备如下功能；

**1、服务注册表**

服务发现组件必须维护一张服务注册表，它记录了各个微服务的信息，例如微服务的名称、IP、端口等。服务注册表提供查询API和管理API，查询API用于查询可用的微服务实例，管理API用于服务的注册和注销。

**2、服务注册与发现**

服务注册是指微服务在启动时，将自己的信息注册到服务发现组件上的过程。服务发现是指查询可用微服务列表及其网路地址的机制。

**3、服务检查**

服务发现组件使用一定机制定时检测已注册的服务，如果发现某实例长时间无法访问，就会从服务注册表中移除该实例。

### 服务发现组件交互流程

* 各个微服务在启动时，将自己的网络地址等信息注册到服务发现组件中，服务发现组件会存储这些信息。
* 服务消费者可从服务发现组件查询服务提供者的网络地址，并使用该地址调用服务提供者的接口。
* 各个微服务与服务发现组件使用一定机制（例如心跳）通信。服务发现组件若长时间无法与某微服务实例通信，就会注销该实例。

### 服务发现架构图

![服务发现架构图](http://f.lingjiatong.cn:30090/rootelement/articleQuote/服务发现架构图.png)

### Eureka原理

![eureka架构图](http://f.lingjiatong.cn:30090/rootelement/articleQuote/eureka架构图.png)


相关概念解释：

* Application Service 应用服务（即服务提供者）
* Application Client 服务客户端（即服务消费者）
* Make Remote Call 远程调用
* us-east-1c、us-east-1d、us-east-1e等都是zone，它们都属于us-east-1这个region

由上图可知，Eureka包含两个组件：Eureka Server和Eureka Client，它们的作用如下：

* **Eureka Server提供服务发现的能力，各个微服务启动时，会向Eureka Server注册自己的信息（例如IP、端口、微服务名称等），Eureka Server会存储这些信息。**
* **Eureka Client是一个Java客户端，用于简化与Eureka Server的交互。**
* **微服务启动后，会周期性地向Eureka Server发送心跳以续约自己的“租期”。**
* **如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将注销该实例（默认90s）**
* **默认情况下，Eureka Server同时也是Eureka Client。多个Eureka Server实例相互之间通过复制的方式来实现服务注册表中数据的同步。**
* **Eureka Clinet会缓存服务注册表中的信息。这种方式有一定的优势——首先，微服务无需每次请求都查询Eureka Server，从而降低了Eureka Server的压力；其次，即使Eureka Server所有节点都宕机，服务消费者依然可以使用缓存中的信息找到服务提供者并完成调用。**

### 将服务注册到EurekaServer的简单Demo

1、创建一个ArtifactId是microservice-discovery-eureka的Maven工程，pom文件内容如下

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <artifactId>spring-boot-starter-parent</artifactId>
        <groupId>org.springframework.boot</groupId>
        <version>1.5.9.RELEASE</version>
    </parent>
    <groupId>com.com.springcloudanddockerbook</groupId>
    <artifactId>microservice-discovery-eureka</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Edgware.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

2、编写启动类，在启动类上面添加@EnableEurekaServer注解，声明这是一个Eureka Server

```java
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }

}
```

3、在配置文件application.yml中添加以下内容：

```yml
server:
  port: 8761
eureka:
  client:
  	# 是否将本微服务注册到eureka中，此处由于自身就是Eureka Server，所以不需要注册
    registerWithEureka: false
    # 是否需要从eureka server获取服务列表，由于本微服务不是服务消费者，所以不需要
    fetch-registry: false
    # 配置eureka交互地址
    service-url:
      defaultZone: http://localhost:8761/eureka/
```

4、测试访问地址[http://localhost:8761](http://localhost:8761)

![image-20211027002657046](http://f.lingjiatong.cn:30090/rootelement/articleQuote/image-20211027002657046-5265625.png)

5、复制项目microservice-simple-provider-user，将ArtifactId修改为microservice-provider-user。

6、在项目中添加以下依赖

```xml
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
```

7、在配置文件中添加以下配置

```yml
spring:
  application:
    name: provider-user
eureka:
  client:
    fetch-registry: true
    register-with-eureka: true
    service-url:
      defaultZone: http://localhost:8761/eureka/
  instance:
    prefer-ip-address: true
```

8、同理可将microservice-simple-consumer-movie改造为microservice-consumer-movie

9、测试

```properties
1、启动microservice-discovery-eureka
2、启动microservice-provider-user
3、启动microservice-consumer-movie
```

![image-20211027003332957](http://f.lingjiatong.cn:30090/rootelement/articleQuote/image-20211027003332957.png)

**注意事项：**

**1、eureka server的页面访问地址为http://localhost:8761，而服务注册的url为http://localhost:8761/eureka，不要弄混**

**2、在Spring Cloud Edgware之前，要想将微服务注册到Eureka Server或其他服务发现组件上，必须在启动类上添加@EnableEurekaClient或者@EnableDiscoveryClient**

**3、若不想将服务注册到Eureka Server，只需要设置spring.cloud.service-registry.auto-registration.enable=false或者@EnableDisCoveryClient(auto-register = false)即可**

### 搭建Eureka高可用环境Demo

在分布式系统中，服务发现组件至关重要，如果服务发现组件宕机，那么会导致严重的后果。不过，eureka客户端会定时连接eureka server，获取服务注册表中的信息并且缓存在本地。每次调用远程服务时都是从缓存中获取。如果eureka server宕机但是服务提供者未宕机，这个时候服务消费者仍可正常访问服务，如果服务提供者也宕机了，那么就无法访问了。因此，需要保证eureka server高可用来及时更新服务信息。

eureka server的高可用原理很简单，就是将多个eureka server相互注册，eureka server实例会彼此增量地同步信息，从而确保所有节点数据一致。

1、复制项目micro service-discovery-eureka，将ArtifactId修改为microservice-discovery-eureka-ha。

2、配置系统的hosts，Windows系统的hosts文件路径是`C:\Windows\System32\drivers\etc\hosts`；Linux以及Mac OS等系统的文件路径是/etc/hosts。

```bash
127.0.0.1 peer1 peer2
```

3、将application.yml修改如下，让两个节点的Eureka Server相互注册。

```yml
spring:
  application:
    name: microservice-discovery-eureka-ha

---
spring:
  profiles: peer1
server:
  port: 8761
eureka:
  instance:
    hostname: peer1
  client:
    service-url:
      defaultZone: http://peer2:8762/eureka/
---
spring:
  profiles: peer2
server:
  port: 8762
eureka:
  instance:
    hostname: peer2
  client:
    service-url:
      defaultZone: http://peer1:8761/eureka/
```

使用连字符（---）将该application.yml文件分为三段。第二段和第三段分别为spring.properties指定了一个值，该值表示它所在的那段内容应用在哪个Profile里。第一段由于并未指定spring.profiles，因此这段内容会对所有Profile生效。

4、pom.xml中加入springboot打包插件

```xml
<build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
</build>
```

5、测试

```properties
1、打包项目，并使用以下命令启动两个Eureka Server节点。
java -jar microservice-discovery-eureka-ha-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1
java -jar microservice-discovery-eureka-ha-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2
通过spring.profiles.active指定使用哪个profile启动。
2、访问http://peer1:8761，会发现“registered-replicas”中已有peer2节点；同理，访问http://peer2:8762，也能发现其中的“registered-replicas”有peer1节点
```

![image-20211027231330467](http://f.lingjiatong.cn:30090/rootelement/articleQuote/image-20211027231330467.png)

### 将应用注册到Eureka Server集群上

只需要将服务提供者的application.yml文件中的eureka.client.serviceUrl.defaultZone配置多个Eureka Server地址，就可以将其注册到Eureka Server集群上了。

```yml
eureka:
  client:
    fetch-registry: true
    register-with-eureka: true
    service-url:
      defaultZone: http://localhost:8761/eureka/, http://localhost:8762/eureka/
  instance:
    prefer-ip-address: true
```

当然，其实只配置其中某个节点也能将服务注册到eureka集群，因为eureka server之间的数据会相互同步。

### Eureka的元数据

eureka的元数据有两种，一种是**标准元数据**，一种是**自定义元数据**。

标准元数据是指主机名、IP地址、端口号、状态页和健康检查等信息，这些信息都会被发布在服务注册表中，用于服务之间的调用。自定义元数据可以使用eureka.instance.metadata-map设置，这些元数据可以在远程客户端中访问，但一般不会改变客户端的行为，除非客户端知道该元数据的含义。

### Eureka的Rest端点

// TODO 待写

### Eureka的自我保护模式

// TODO 待写

### Eureka的健康检查

// TODO 待写



## 第五章 使用Ribbon实现客户端侧负载均衡

学习重点：

1、eureka与ribbon配合使用demo

2、ribbon自定义负载均衡算法

3、脱离eureka使用ribbon

### eureka与ribbon配合使用

ribbon是netflix发布的负载均衡器，它有助于控制HTTP和TCP客户端的行为。为ribbon配置服务提供者地址列表后，ribbon就可以基于某种负载均衡算法，自动地帮助服务消费者去请求。ribbon默认为我们提供了很多负载均衡算法，例如轮询、随机等。当然，我们也可为ribbon实现自定义的负载均衡算法。

eureka与ribbon配置使用的架构图如下：

![Eureka与Ribbon配合使用架构图](http://f.lingjiatong.cn:30090/rootelement/articleQuote/Eureka与Ribbon配合使用架构图.png)

### 服务消费者整合ribbon案例

1、复制项目microservice-consumer-movie，将ArtifactId改为microservice-consumer-movie-ribbon。

2、为项目引入ribbon的依赖，ribbon的依赖如下：

```xml
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
        </dependency>
```

由于前文中电影微服务添加了spring-cloud-stater-netflix-eureka-client，该依赖已包含spring-cloud-stater-netflix-ribbon，因此无需再次引入。

3、为RestTemplate添加`@LoadBalanced`注解

```java

@SpringBootApplication
@EnableEurekaClient
public class ConsumerMovieApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConsumerMovieApplication.class, args);
    }

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

}

```

4、对controller进行修改

```java

@Slf4j
@RestController
public class MovieController {

    @Autowired
    private RestTemplate restTemplate;
    @Autowired
    private LoadBalancerClient loadBalancerClient;

    @GetMapping("/user/{id}")
    public User findById(@PathVariable Long id)  {
        return restTemplate.getForObject("http://microservice-provider-user/" + id, User.class);
    }

    @GetMapping("/log-user-instance")
    public void logUserInstance()  {
        ServiceInstance serviceInstance = loadBalancerClient.choose("microservice-provider-user");
        log.info("{}:{}:{}", serviceInstance.getServiceId(), serviceInstance.getHost(), serviceInstance.getPort());
    }
}

```

由代码可知，将请求的地址改为`http://microservice-provider-user/`。microservice-provider-user是用户微服务的`虚拟主机名（virtual host name）`，当ribbon和eureka配合使用时，会自动将虚拟主机名映射成微服务的网络地址。在新增的log-user-instance()方法中可使用LoadBalancerClient的API更加直观地获取当前选择的用户微服务节点。

5、测试

```properties
1、启动microservice-discovery-eureka
2、启动2个或更多microservice-provider-user实例
3、启动microservice-consumer-movie-ribbon
4、访问http://localhost:8761查看eureka，如下图所示
```

![](http://f.lingjiatong.cn:30090/rootelement/articleQuote/16354388573588.jpg)

```properties

5、多次访问http://localhost:8001/user/1，返回结果如下：
{
    "id": 1,
    "username": "account1",
    "name": "张三",
    "age": 20,
    "balance": 100
}
同时两个用户微服务实例都会打印类似如下的日志：
2021-10-29 00:37:55.182 TRACE 2614 --- [io-8000-exec-10] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [BIGINT] - [1]
2021-10-29 00:37:55.183 TRACE 2614 --- [io-8000-exec-10] o.h.type.descriptor.sql.BasicExtractor   : extracted value ([age2_0_0_] : [INTEGER]) - [20]
2021-10-29 00:37:55.183 TRACE 2614 --- [io-8000-exec-10] o.h.type.descriptor.sql.BasicExtractor   : extracted value ([balance3_0_0_] : [NUMERIC]) - [100.00]
2021-10-29 00:37:55.183 TRACE 2614 --- [io-8000-exec-10] o.h.type.descriptor.sql.BasicExtractor   : extracted value ([name4_0_0_] : [VARCHAR]) - [张三]
2021-10-29 00:37:55.183 TRACE 2614 --- [io-8000-exec-10] o.h.type.descriptor.sql.BasicExtractor   : extracted value ([username5_0_0_] : [VARCHAR]) - [account1]

6、多次访问http://localhost:8001/log-user-instance，控制台会打印如下日志：
2021-10-29 00:20:46.379  INFO 2602 --- [nio-8001-exec-4] c.s.movie.controller.MovieController     : microservice-provider-user:192.168.137.236:8002
2021-10-29 00:20:46.963  INFO 2602 --- [nio-8001-exec-5] c.s.movie.controller.MovieController     : microservice-provider-user:192.168.137.236:8000
2021-10-29 00:20:47.267  INFO 2602 --- [nio-8001-exec-6] c.s.movie.controller.MovieController     : microservice-provider-user:192.168.137.236:8002
2021-10-29 00:20:47.412  INFO 2602 --- [nio-8001-exec-7] c.s.movie.controller.MovieController     : microservice-provider-user:192.168.137.236:8000
2021-10-29 00:20:47.549  INFO 2602 --- [nio-8001-exec-8] c.s.movie.controller.MovieController     : microservice-provider-user:192.168.137.236:8002
```

可以看到，此时请求会均匀分布到两个用户微服务节点上，说明已经实现了负载均衡。

tips：
> * 虚拟主机名与虚拟IP非常类似，可使用配置属性**eureka.instance.virtual-host-name**或者**eureka.instance.secure-virtual-host-name**指定虚拟主机名。
> * 不能将**restTemplate.getForObject**与**loadBalancerClient.choose**写在同一个方法中，两者之间会有冲突——因为此时代码中的restTemplate实际上是一个Ribbon客户端，本身已经包含了“choose”的行为。

### 自定义Ribbon的负载均衡策略

// TODO 没看懂，需要继续深入了解

### 脱离Eureka使用Ribbon

在前面的示例中，是将Ribbon与Eureka配合使用的

## 第六章 使用Feign实现声明式REST调用

学习重点：

1、消费者整合Feign案例学习

2、自定义Feign配置学习

3、Feign在各种参数场景下使用demo学习

4、使用Feign上传文件使用demo学习


### 消费者业务整合Feign

1、复制项目microservice-consumer-movie，将ArtifactId修改为microservice-consumer-movie-feign。

2、添加Feign依赖（openFeign依赖）

```xml
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
```

3、创建一个Feign接口，并添加@FeignClient注解

```java
@FeignClient(name = "microservice-provider-user")
public interface UserFeignClient {

    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    User findById(@PathVariable("id") Long id);

}
```
此处有两点需要特殊说明：
> 1、@FeignClient的name属性是一个**任意**的名称，用于创建ribbon负载均衡器。**如果项目中使用了Eureka，ribbon会把name解析为服务注册表中的服务名**
> 2、可以使用url属性指定具体调用的请求的URL，例如：@FeignClient(name = "xxx", url = "http://localhost:8000/")，则只会请求8000端口的服务

4、修改Controller代码，让其调用Feign接口

```java

@RestController
public class MovieController {


    @Autowired
    private UserFeignClient userFeignClient;

    @GetMapping("/user/{id}")
    public User findById(@PathVariable Long id)  {
        return userFeignClient.findById(id);
    }
}
```

5、修改启动类，为其添加@EnableFeignClient注解，如下

```java
@SpringBootApplication
@EnableEurekaClient
@EnableFeignClients
public class ConsumerMovieApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConsumerMovieApplication.class, args);
    }

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }

}

```

6、测试

```properties
1、启动microservice-discovery-eureka
2、启动2个或者更多micorservice-provider-user实例
3、启动microservice-consumer-movie-feign
4、多次访问http://localhost:8001/user/1，返回如下结果
{
    "id": 1,
    "username": "account1",
    "name": "张三",
    "age": 20,
    "balance": 100
}
5、两个用户微服务都会打印类似如下的日志
2021-10-31 00:07:07.974 TRACE 24154 --- [nio-8000-exec-5] o.h.type.descriptor.sql.BasicBinder      : binding parameter [1] as [BIGINT] - [1]
2021-10-31 00:07:07.974 TRACE 24154 --- [nio-8000-exec-5] o.h.type.descriptor.sql.BasicExtractor   : extracted value ([age2_0_0_] : [INTEGER]) - [20]
2021-10-31 00:07:07.974 TRACE 24154 --- [nio-8000-exec-5] o.h.type.descriptor.sql.BasicExtractor   : extracted value ([balance3_0_0_] : [NUMERIC]) - [100.00]
2021-10-31 00:07:07.974 TRACE 24154 --- [nio-8000-exec-5] o.h.type.descriptor.sql.BasicExtractor   : extracted value ([name4_0_0_] : [VARCHAR]) - [张三]
2021-10-31 00:07:07.974 TRACE 24154 --- [nio-8000-exec-5] o.h.type.descriptor.sql.BasicExtractor   : extracted value ([username5_0_0_] : [VARCHAR]) - [account1]
以上结果说明，我们不但实现了声明式的REST API调用，同时还实现了客户端测的负载均衡

```

### 自定义Feign配置

在SpringCloud中，Feign的默认配置类是FeignClientsConfiguration，该类定义了Feign默认使用的**编码器、解码器、所使用的契约**等。

**SpringCloud允许通过注解@FeignClient的configuration属性自定义Feign的配置，自定义配置的优先级比FeignClientConfiguration要高。**

使用@FeignClient的configuration属性自定义Feign配置示例如下：

1、复制项目microservice-consumer-movie-feign，将ArtifactId修改为microservice-consumer-movie-feign-customizing。

2、创建feign的配置类

```java

public class FeignConfiguration {

    @Bean
    public Contract feignContract() {
        return new feign.Contract.Default();

    }
}
```

3、Feign接口修改为如下，使用@FeignClient的configuration属性指定配置类，同时，将findById上的SpringMVC注解修改为Feign自带的注解。

```java
@FeignClient(name = "MICROSERVICE-PROVIDER-USER", configuration = FeignConfiguration.class)
public interface UserFeignClient {

    @RequestLine("GET /{id}")
    User findById(@Param("id") Long id);

}

```

4、测试

```properties
1、启动microservice-discovery-eureka
2、启动microservice-provider-user
3、启动microservice-consumer-movie-feign-customizing
4、访问http://localhost:8004/user/1，可获得如下结果
{
    "id": 1,
    "username": "account1",
    "name": "张三",
    "age": 20,
    "balance": 100
}

```
tips:
> 1、在SpringCloud中，Feign的配置类（例如本例中的FeignConfiguration类）无须添加@Configuration注解；如果加了@Configuration注解，那么该配置中的feign.Decoder、feign.Encoder、Feign.Contract等配置就会被所有的@FeignClient共享。
> 为避免造成问题，最佳实践是不在指定名称的Feign配置类上添加@Configuration注解。

### 使用配置文件指定特定FeignClient的配置

从SpringCloud Edgware开始，Feign支持使用属性自定义。这种方式比使用Java代码配置的方式更加方便。

1、复制项目microservice-consumer-movie-feign，修改ArtifactId为microservice-consumer-movie-feign-customizing-yml

2、修改配置application.yml配置文件的内容，加上如下内容

```yml

feign:
  client:
    config:
      MICROSERVICE-PROVIDER-USER:
        # 相当于Request.Options
        connectTimeout: 5000
        # 相当于Request.Options
        readTimeout: 5000
        # 配置Feign的日志级别，相当于代码配置方式中的Logger
        loggerLevel: full
        # feign的错误解码器，相当于代码配置方式中的ErrorDecoder
        errorDecoder: com.springcloudanddockerbook.movie.SimpleErrorDecoder
        # 配置重试，这里使用的是feign默认实现的重试器
        retryer: feign.Retryer.Default
        # 配置拦截器，相当于代码配置方式中的RequestInterceptor
        requestInterceptors:
          - com.springcloudanddockerbook.movie.FooRequestInterceptor
        decode404: false
```

4、错误解码器和拦截器

```java

// 错误解码器 com.springcloudanddockerbook.movie.SimpleErrorDecoder
public class SimpleErrorDecoder implements ErrorDecoder {


    @Override
    public Exception decode(String methodKey, Response response) {
        return new RuntimeException("出问题了");
    }
}

// 拦截器 com.springcloudanddockerbook.movie.FooRequestInterceptor

@Slf4j
public class FooRequestInterceptor implements RequestInterceptor {

    @Override
    public void apply(RequestTemplate template) {
        log.info("=============请求地址：" + template.url());
    }
}

```

5、启动测试

```properties
1、启动microservice-discovery-eureka
2、启动microservice-provider-user
3、启动microservice-consumer-movie-feign-customizing-yml
4、访问http://localhost:8005/user/1，可获得如下结果
{
    "id": 1,
    "username": "account1",
    "name": "张三",
    "age": 20,
    "balance": 100
}
5、从控制台可看到如下打印信息
2021-10-31 09:44:35.279  INFO 26465 --- [nio-8005-exec-6] c.s.movie.FooRequestInterceptor          : =============请求地址：/1

```

tips：
> 1、以上这些配置内容实际上就是配置一个FeignConfiguraion类，这个类有什么属性，可以查看原类来了解。这些配置具体的实现就不再赘述。
> 2、如果想使用配置文件指定所有feign客户端的通用配置，可以将feign.client.config中的客户端名改为default，例如feign.client.config.default

### 手动创建Feign

在某些场景下，前文自定义的Feign的方式满足不了需求，此时可使用Feign Builder API手动创建Feign。

下面围绕以下场景，实现手动创建Feign的案例：

* 用户微服务的接口需要登陆后才能调用，并且对于相同的API，不同角色的用户有不同的行为。
* 让电影微服务中的同一个Feign接口使用不同的账号登陆，并调用用户微服务的接口。

1、复制项目microservice-provider-user，将ArtifactId修改为microservice-provider-user-with-auth。

2、为项目添加如下依赖：

```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

```

3、创建Spring Security配置类

```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // 所有的请求，都需要经过HTTP basic 认证
        http
                .authorizeRequests()
                .anyRequest()
                .authenticated()
                .and()
                .httpBasic();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        // 不做任何处理的密码编码器，是spring提供的测试用的
        return NoOpPasswordEncoder.getInstance();
    }

    @Autowired
    private CustomUserDetailsService userDetailsService;


    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth
                .userDetailsService(userDetailsService)
                .passwordEncoder(passwordEncoder());
    }

    @Component
    class CustomUserDetailsService implements UserDetailsService {

        /**
         * 模拟两个账户
         * 1 账户是user，密码是password1，角色是user-role
         * 2 账户是admin，密码是password2，角色是admin-role
         *
         * @param s
         * @return
         * @throws UsernameNotFoundException
         */
        @Override
        public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
            if ("user".equals(s)) {
                return new SecurityUser("user", "password1", "user-role");
            } else if ("admin".equals(s)) {
                return new SecurityUser("admin", "password2", "admin-role");
            } else {
                return null;
            }
        }
    }


    @Data
    class SecurityUser implements UserDetails {
        private Long id;
        private String username;
        private String password;
        private String role;

        public SecurityUser(String username, String password, String role) {
            this.username = username;
            this.password = password;
            this.role = role;
        }

        public SecurityUser() {
        }

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            Collection<GrantedAuthority> grantedAuthorities = new ArrayList<>();
            SimpleGrantedAuthority grantedAuthority = new SimpleGrantedAuthority(this.role);
            grantedAuthorities.add(grantedAuthority);
            return grantedAuthorities;
        }

        @Override
        public boolean isAccountNonExpired() {
            return true;
        }

        @Override
        public boolean isAccountNonLocked() {
            return true;
        }

        @Override
        public boolean isCredentialsNonExpired() {
            return true;
        }

        @Override
        public boolean isEnabled() {
            return true;
        }
    }
}

```
代码中模拟了两个账号：**user和admin**，他们的密码分别是**password1和password2**，角色分别是**user-role和user-admin**。

4、修改controller

```java

@Slf4j
@RestController
public class UserController {

    @Autowired
    private UserRepository userRepository;

    @GetMapping("/{id}")
    public User findById(@PathVariable Long id) {
        Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        if (principal instanceof UserDetails) {
            UserDetails user = (UserDetails) principal;
            Collection<? extends GrantedAuthority> authorities = user.getAuthorities();
            for (GrantedAuthority authority : authorities) {
                log.info("当前用户是：{}, 角色是：{}", user.getUsername(), authority.getAuthority());
            }
        } else {

        }
        User user = userRepository.findOne(id);
        return user;
    }


}
```

5、测试

```properties

1、启动microservice-discovery-eureka
2、启动microservice-provider-user-with-auth
3、访问http://localhost:8000/1，将弹出登陆框
4、输入user/password1登陆，可以看到如下日志
2021-10-31 12:04:50.696  INFO 27279 --- [nio-8006-exec-2] c.s.user.controller.UserController       : 当前用户是：user, 角色是：user-role
Hibernate: select user0_.id as id1_0_0_, user0_.age as age2_0_0_, user0_.balance as balance3_0_0_, user0_.name as name4_0_0_, user0_.username as username5_0_0_ from user user0_ where user0_.id=?
5、使用admin/password2登陆也是类似
```

6、修改电影微服务

复制项目microservice-consumer-movie-feign，将ArtifactId改为microservice-consumer-movie-feign-manual

7、去掉Feign接口UserFeignClient上的@FeignClient注解

8、去掉启动类上的@EnableFeignClient注解

9、修改Controller如下

```java
@Import(FeignClientsConfiguration.class)
@RestController
public class MovieController {

    private UserFeignClient userUserFeignClient;

    private UserFeignClient adminUserFeignClient;

    @Autowired
    public MovieController(Decoder decoder, Encoder encoder, Client client, Contract contract) {
        this.userUserFeignClient = Feign.builder()
                .client(client)
                .encoder(encoder)
                .decoder(decoder)
                .contract(contract)
                .requestInterceptor(new BasicAuthRequestInterceptor("user", "password1"))
                .target(UserFeignClient.class, "http://microservice-provider-user-with-auth/");
        this.adminUserFeignClient = Feign.builder()
                .client(client)
                .encoder(encoder)
                .decoder(decoder)
                .contract(contract)
                .requestInterceptor(new BasicAuthRequestInterceptor("admin", "password2"))
                .target(UserFeignClient.class, "http://microservice-provider-user-with-auth/");
    }

    @GetMapping("/user-user/{id}")
    public User findByIdUser(@PathVariable Long id)  {
        return userUserFeignClient.findById(id);
    }

    @GetMapping("/user-admin/{id}")
    public User findByIdAdmin(@PathVariable Long id)  {
        return adminUserFeignClient.findById(id);
    }
}

```

其中，@Import导入的FeignClientConfiguration是SpringCloud为Feign默认提供的配置类。

userUserFeignClient登陆账号user，adminUserFeignClient登陆账号admin，他们使用的是同一个接口UserFeignClient。

8、测试

```properties
1、启动microservice-discovery-eureka
2、启动microservice-provider-user-with-auth
3、启动microservice-consumer-movie-feign-manual
4、访问http://localhost:8001/user-user/1，可以正常获得查询结果，同时可以看到用户微服务打印如下日志
2021-10-31 12:20:29.085  INFO 27291 --- [nio-8006-exec-9] c.s.user.controller.UserController       : 当前用户是：user, 角色是：user-role
Hibernate: select user0_.id as id1_0_0_, user0_.age as age2_0_0_, user0_.balance as balance3_0_0_, user0_.name as name4_0_0_, user0_.username as username5_0_0_ from user user0_ where user0_.id=?
5、访问http://localhost:8001/user-admin/1也是相似的结果

```

### 关于Feign的一些细节

// TODO 待写


## 第七章 使用Hystrix实现微服务的容错处理

学习重点：

1、微服务容错处理的概念和解决了什么问题

2、使用Hystrix实现容错demo

3、Hystrix深入理解

4、Hystrix整合Feign


### 微服务容错处理概念

微服务架构的应用系统通常包含多个服务层。微服务之间通过网络进行通信，从而支撑起整个应用系统，因此，微服务之间难免存在依赖关系。我们知道，任何微服务都并非100%可用，网络往往也很脆弱，因此难免有些请求会失败。

我们常把“基础服务故障”导致“级联故障”的现象称为**雪崩效应**。雪崩效应描述的是提供者不可用导致消费者不可用，并将不可用逐渐放大的过程。

雪崩效应形成过程如下图：

// TODO 待画

为了避免雪崩效应，需要一个容错机制，该容错机制需实现以下两点：

1、为网络请求设置超时时间

必须为网络请求设置超时，正常情况下，一个远程调用一般在几十毫秒内就能得到响应了。如果依赖的服务不可用或者网络有问题，那么响应时间就会变得很长（几十秒）。

通常情况下，一次远程调用对应着一个线程/进程。如果响应太慢，这个线程/进程就得不到释放。而线程/进程又对应着系统资源，如果得不到释放的线程/进程越积越多，资源就会逐渐被耗尽，最终导致服务的不可用。

因此，必须为每个网络请求设置超时，让资源尽快释放。

2、使用断路器模式

如果对某个微服务的请求有大量超时（常常说明该微服务不可用），再去让新的请求访问该服务已经没有任何意义，只会无谓的消耗资源。断路器可以实现微服务调用的快速失败和自我修复。

断路器状态转换图如下：


### 使用Hystrix实现容错demo

Hystrix是由Netflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。Hystrix主要通过以下几点实现延迟和容错。

* 包裹请求：使用HystrixCommand（或HystrixObservableCommand）包裹对依赖的调用逻辑，每个命令在独立线程中执行。这使用了设计模式中的“命令模式”。
* 跳闸机制：当某个服务的错误率超过一定阈值时，Hystrix可以自动或者手动跳闸，停止请求该服务一段时间。
* 资源隔离：Hystrix为每个依赖都维护了一个小型的线程池（或者信号量）。如果该线程池已满，发往该依赖的请求就被立即拒绝，而不是排队等候，从而加速失败判定。
* 监控：Hystrix可以近乎实时地监控运行指标和配置的变化，例如成功、失败、超时和被拒绝的请求等。
* 回退机制：当请求失败、超时、被拒绝，或当断路器被打开时，执行回退逻辑。回退逻辑可由开发人员自行提供，例如返回一个缺省值。
* 自我修复：断路器打开一段时间后，会自动进入“半开”状态。断路器打开、关闭、半开的逻辑转换，前面已经详细探讨过了，本小节不在赘述。


1、复制项目microservice-consumer-movie-ribbon，将ArtifactId修改为microsevice-consumer-movie-ribbon-hystrix。

2、为项目添加如下依赖：

```xml

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>

```

3、在启动类上添加注解@EnableCircuitBreaker或者@EnableHystrix，从而为项目启动断路器支持。

4、修改MovieController，让其中的findById方法具备容错能力。

```java
@Slf4j
@RestController
public class MovieController {

    @Autowired
    private RestTemplate restTemplate;
    @Autowired
    private LoadBalancerClient loadBalancerClient;

    @HystrixCommand(fallbackMethod = "findByIdFallback")
    @GetMapping("/user/{id}")
    public User findById(@PathVariable Long id)  {
        return restTemplate.getForObject("http://microservice-provider-user/" + id, User.class);
    }

    @GetMapping("/log-user-instance")
    public void logUserInstance()  {
        ServiceInstance serviceInstance = loadBalancerClient.choose("microservice-provider-user");
        log.info("{}:{}:{}", serviceInstance.getServiceId(), serviceInstance.getHost(), serviceInstance.getPort());
    }

    public User findByIdFallback(Long id) {
        User user = new User();
        user.setId(-1L);
        user.setName("默认用户");
        return user;
    }
}

```

5、测试

```properties

1、启动项目microservice-discovery-eureka
2、启动项目microservice-provider-user
3、启动项目microservice-consumer-movie-ribbon-hystrix
4、访问http://localhost:8001/user/1，可获得如下结果
{
    "id": 1,
    "username": "account1",
    "name": "张三",
    "age": 20,
    "balance": 100
}
5、停止microservice-provider-user
6、再次访问http://localhost:8001/user/1，获得结果如下
{
    "id": -1,
    "username": null,
    "name": "默认用户",
    "age": null,
    "balance": null
}

```

tips：

1、可以在hystrix配置的回退方法中加一个Throwable类型的参数来获取造成回退的原因，本例中可以将MovieController类配置为如下：

```java

@Slf4j
@RestController
public class MovieController {

    @Autowired
    private RestTemplate restTemplate;
    @Autowired
    private LoadBalancerClient loadBalancerClient;

    @HystrixCommand(fallbackMethod = "findByIdFallback")
    @GetMapping("/user/{id}")
    public User findById(@PathVariable Long id)  {
        return restTemplate.getForObject("http://microservice-provider-user/" + id, User.class);
    }

    @GetMapping("/log-user-instance")
    public void logUserInstance()  {
        ServiceInstance serviceInstance = loadBalancerClient.choose("microservice-provider-user");
        log.info("{}:{}:{}", serviceInstance.getServiceId(), serviceInstance.getHost(), serviceInstance.getPort());
    }

    public User findByIdFallback(Long id, Throwable throwable) {
        User user = new User();
        user.setId(-1L);
        user.setName("默认用户");
        log.error("==========异常原因：", throwable);
        return user;
    }
}


```

2、多数场景下，当业务发生异常时，我们并不想触发fallback。此时可以通过自定义异常继承HystrixBadRequestException类来达到业务异常不触发hystrix回退的效果。另外，@HystrixCommand为我们提供了ignoreException属性，也可借助该属性来配置不想执行回退的异常类。例如：

```java

@Slf4j
@RestController
public class MovieController {

    @Autowired
    private RestTemplate restTemplate;
    @Autowired
    private LoadBalancerClient loadBalancerClient;

    @HystrixCommand(fallbackMethod = "findByIdFallback", ignoreExceptions = {IllegalArgumentException.class})
    @GetMapping("/user/{id}")
    public User findById(@PathVariable Long id)  {
        return restTemplate.getForObject("http://microservice-provider-user/" + id, User.class);
    }

    @GetMapping("/log-user-instance")
    public void logUserInstance()  {
        ServiceInstance serviceInstance = loadBalancerClient.choose("microservice-provider-user");
        log.info("{}:{}:{}", serviceInstance.getServiceId(), serviceInstance.getHost(), serviceInstance.getPort());
    }

    public User findByIdFallback(Long id, Throwable throwable) {
        User user = new User();
        user.setId(-1L);
        user.setName("默认用户");
        log.error("==========异常原因：", throwable);
        return user;
    }
}

```

这样，即使在findById中发生IllegalArgumentException也不会执行findByIdFallback方法。

### Hystrix断路器的状态监控与深入理解

hystrix的状态也会暴露在actuator端点中，下面来做一点实验，深入理解断路器的状态转换。

测试：

```properties

1、启动项目microservice-discovery-eureka
2、启动项目microservice-provider-user
3、启动项目microservice-consumer-movie-ribbon-hystrix
4、访问http://localhost:8001/user/1，可正常获取的结果
5、访问http://localhost:8001/health，可获得类似如下结果
{
    "description": "Composite Discovery Client",
    "status": "UP",
    "discoveryComposite": {
        "description": "Composite Discovery Client",
        "status": "UP",
        "discoveryClient": {
            "description": "Composite Discovery Client",
            "status": "UP",
            "services": [
                "consumer-movie",
                "microservice-provider-user"
            ]
        },
        "eureka": {
            "description": "Remote status from Eureka server",
            "status": "UP",
            "applications": {
                "CONSUMER-MOVIE": 1,
                "MICROSERVICE-PROVIDER-USER": 1
            }
        }
    },
    "diskSpace": {
        "status": "UP",
        "total": 1000240963584,
        "free": 667935416320,
        "threshold": 10485760
    },
    "refreshScope": {
        "status": "UP"
    },
    "hystrix": {
        "status": "UP"
    }
}

```

注意：出现以上结果，需要在项目中添加actuator依赖，并且要在配置文件中打开监控端点

```yml

# 开放所有端点
management:
  security:
    enabled: false

```

```properties

6、停止microservice-provider-user，访问http://localhost:8001/user/1，可获得如下结果
{
    "id": -1,
    "username": null,
    "name": "默认用户",
    "age": null,
    "balance": null
}

7、访问http://localhost:8001/health，可获得如下结果
{
    "description": "Composite Discovery Client",
    "status": "UP",
    "discoveryComposite": {
        "description": "Composite Discovery Client",
        "status": "UP",
        "discoveryClient": {
            "description": "Composite Discovery Client",
            "status": "UP",
            "services": [
                "consumer-movie"
            ]
        },
        "eureka": {
            "description": "Remote status from Eureka server",
            "status": "UP",
            "applications": {
                "CONSUMER-MOVIE": 1
            }
        }
    },
    "diskSpace": {
        "status": "UP",
        "total": 1000240963584,
        "free": 667938123776,
        "threshold": 10485760
    },
    "refreshScope": {
        "status": "UP"
    },
    "hystrix": {
        "status": "UP"
    }
}

```

我们发现，尽管执行了回退逻辑，返回了默认用户，但此时Hystrix的状态依然是UP，这是因为我们的失败率还没有达到阈值（默认是5s内20次失败）。这里需要说明的是，执行回退逻辑并不代表断路器已经打开。请求失败、超时、被拒绝以及断路器打开时等都会执行回退逻辑。

```properties

8、持续快速的访问http://localhost:8001/user/1，直到请求快速返回。此时，访问http://localhost:8001/health可获得如下的结果

{
    "description": "Composite Discovery Client",
    "status": "UP",
    "discoveryComposite": {
        "description": "Composite Discovery Client",
        "status": "UP",
        "discoveryClient": {
            "description": "Composite Discovery Client",
            "status": "UP",
            "services": [
                "consumer-movie"
            ]
        },
        "eureka": {
            "description": "Remote status from Eureka server",
            "status": "UP",
            "applications": {
                "CONSUMER-MOVIE": 1,
                "MICROSERVICE-PROVIDER-USER": 0
            }
        }
    },
    "diskSpace": {
        "status": "UP",
        "total": 1000240963584,
        "free": 667939819520,
        "threshold": 10485760
    },
    "refreshScope": {
        "status": "UP"
    },
    "hystrix": {
        "status": "CIRCUIT_OPEN",
        "openCircuitBreakers": [
            "MovieController::findById"
        ]
    }
}

```

可以看到，Hystrix的状态是CIRCUIT_OPEN，说明断路器已经打开，不会再去请求用户微服务了。我们也可以使用类似方法去测试断路器从打开转半开以及从半开自动恢复等过程。

### Hystrix线程隔离策略与传播上传文



## 第八章 使用Zuul构建微服务网关



## 第九章 使用Spring Cloud Config统一管理微服务配置

学习重点：

1、Spring Cloud Config例子（使用github作为存储）

2、自动刷新配置demo学习

### 使用Spring Cloud Config集中管理微服务配置文件

在微服务架构中，微服务的配置管理一般有以下需求：

* 集中管理配置。一个使用微服务架构的应用系统可能会包含成百上千个微服务，因此集中管理配置是非常有必要的。
* 不同环境，不同配置。例如，数据源配置在不同的环境（开发、测试、预发布、生产等）中是不同的。
* 运行时可动态调整。例如，可根据各个微服务的负载情况，动态调整数据源连接池大小或熔断阈值，并且在调整配置时不停止微服务。
* 配置修改后可自动更新。如配置内容发生变化，微服务能自动更新配置。

使用Github作为Spring Cloud Config存储引擎时的架构图如下：

![Spring Cloud Config 架构图](http://f.lingjiatong.cn:30090/rootelement/articleQuote/Spring%20Cloud%20Config%20%E6%9E%B6%E6%9E%84%E5%9B%BE.png)


1、在Github新建几个配置文件，例如：

```properties

microservice-foo.properties
microservice-foo-dev.properties
microservice-foo-test.properties
microservice-foot-production.properties

```

为了测试版本控制，为该Git仓库创建config-label-v2.0分支，并将各个配置文件中的1.0改为2.0

2、创建一个Maven工程，ArtifactId是microservice-config-server，并为项目添加以下依赖。

```xml

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-config-server</artifactId>
        </dependency>

```

3、编写启动类，在启动类上添加注解@EnableConfigServer，声明这是一个Config Server。

```java

@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApplication.class, args);
    }

}

```

4、编写配置文件application.yml，并在其中添加以下内容。

```yml

server:
  port: 8050
spring:
  application:
    name: microservice-config-server
  cloud:
    config:
      server:
        git:
          uri: <git仓库地址>
          username: <git仓库用户名>
          password: <git仓库密码>

```

这样，一个Config Server就完成了。

可以使用Config Server的端点获取配置文件的内容。端点与配置文件的映射规则如下：

```properties

/{application}/{profile}[/{label}]
/{application}-{profile}.yml
/{label}/{application}-{profile}.yml
/{application}-{profile}.properties
/{label}/{application}-{profile}.properties

```

以上端点都可以映射到{application}-{profile}.properties这个配置文件，{application}表示微服务的名称，{label}对应Git仓库的分支，默认是master。

按照以上规则，对于本例，可使用以下URL访问到Git仓库master分支的microservice-foo-dev-properties，例如：

* http://localhost:8050/microservice-foo/dev
* http://localhost:8050/microservice-foo-dev.properties
* http://localhost:8050/microservice-foo-dev.yml

5、测试：

```properties

1、访问http://localhost:8050/microservice-foo/dev，可获得如下结果。
{
    "name": "microservice-foo",
    "profiles": [
        "dev"
    ],
    "label": null,
    "version": "2f76fe3dfdfac16d00661511dae27bfa0ec9d224",
    "state": null,
    "propertySources": [
        {
            "name": "https://github.com/ljtnono/springcloudanddockerbootconfig.git/microservice-foo-dev.properties",
            "source": {
                "profile": "dev-1.0"
            }
        },
        {
            "name": "https://github.com/ljtnono/springcloudanddockerbootconfig.git/microservice-foo.properties",
            "source": {
                "profile": "default-1.0"
            }
        }
    ]
}

从结果可以直观的看到应用名称，项目profile，Git label、Git version、配置文件URL，配置详情等信息。

2、访问http://localhost:8050/microservice-foo-dev.properties,返回配置文件中的属性：

profile: dev-1.0

3、访问http://localhost:8050/config-label-v2.0/microservice-foo-dev.properties，可获得如下结果：

profile: dev-2.0

说明已经获得了Git仓库config-label-v2.0分支中的配置信息。

```

至此，已成功构建了ConfigServer，并通过构造URL的方式，获取了Git仓库中的配置信息。

6、构建完ConfigServer之后还需要构建ConfigClient，创建一个Maven工程，ArtifactId是microservice-config-client，并为项目添加以下依赖。

```xml

   <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
    </dependencies>

```

7、创建一个基本的Spring Boot启动类。

```java

@SpringBootApplication
public class ConfigApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConfigApplication.class, args);
    }
}


```

8、编写配置文件application.yml，并在其中添加如下内容：

```yml

server:
  port: 8060

```

9、创建配置文件bootstrap.yml，并在其中添加如下内容：

```yml

spring:
  application:
    name: microservice-config-client
  cloud:
    config:
      # config server的地址
      uri: http://localhost:8050/
      # 获取的profile
      profile: dev
      # git仓库的分支
      label: master
      # 获取的是哪一个配置文件
      name: microservice-foo

```

10、编写controller

```java

@RestController
public class ConfigClientController {

    @Value("${profile}")
    private String profile;


    @GetMapping("/profile")
    public String hello() {
        return profile;
    }
}

```

11、测试：

```properties

1、启动microservice-config-server  

2、启动microservice-config-client

3、访问http://localhost:8060/profile

dev-1.0

说明Config Client能够正常通过Config Server获得Git仓库中对应环境的配置。

```

### 使用/refresh端点手动刷新配置

1、在microservice-config-client的controller上添加@RefreshScope。添加@RefreshScope的类会在配置更改时得到特殊的处理。

```java

@RefreshScope
@RestController
public class ConfigClientController {

    @Value("${profile}")
    private String profile;


    @GetMapping("/profile")
    public String hello() {
        return profile;
    }
}

```

2、测试

```properties

1、启动microservice-config-server

2、启动microservice-config-client

3、访问http://localhost:8060/profile，获得结果: dev-1.0

4、修改Git仓库中microservice-foo-dev.properties文件内容为profile=dev-1.0-change。

5、重新访问http://localhost:8060/profile，发现结果依然是dev-1.0，说明配置尚未刷新。

6、发送POST请求到http://localhost:8060/refresh，例如：

curl -X POST http://localhost:8060/refresh

返回结果：["config.client.version","profile"]，表示profile这个配置属性已被刷新，需要注意的是，如果没有配置management.security.enable=false，该端点是无法访问的。

7、再次访问http://localhost:8060/profile，返回dev-1.0-change，说明配置已经刷新。


```

### 使用Spring Cloud Bus自动刷新配置

前文讨论了使用/refresh端点手动刷新配置，但如果所有微服务节点的配置都需要手动去刷新，工作量可想而知。不仅如此，随着系统的不断扩张，会越来越难以维护。因此，实现配置的自动刷新是很有必要的。

Spring Cloud Bus使用轻量级消息代理（例如：RabbitMQ、Kafka等）连接分布式系统的节点，这样就可以广播传播状态的更改（例如配置的更新）或者其他的管理指令。可将Spring Cloud Bus想象成一个分布式的Spring Boot Actuator。使用Spring Cloud Bus后的架构图如图所示：


![使用Spring Cloud Bus架构图](http://f.lingjiatong.cn:30090/rootelement/articleQuote/%E4%BD%BF%E7%94%A8Spring%20Cloud%20Bus%E6%9E%B6%E6%9E%84%E5%9B%BE.png)


由上图可知，微服务A的所有实例都通过消息总线连接到一起，每个实例都会订阅配置更新事件。当其中一个微服务节点的/bus/refresh端点被请求时，该实例就会向消息总线发送一个配置更新事件，其他实例获得该事件后也会更新配置。


1、安装rabbitmq，为项目microservice-config-client添加如下依赖

```xml

        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-bus-amqp</artifactId>
        </dependency>

```

2、启动microservice-config-client，可发现控制台会输出类似如下的内容

```properties

Mapped "{[/bus/refresh],methods=[POST]}" onto public void org.springframework.cloud.bus.endpoint.RefreshBusEndpoint.refresh(java.lang.String)

```

3、将microservice-config-client的端口改为8070，再启动一个节点。

4、访问http://localhost:8060/profile，可获得结果：dev-1.0，访问http://localhost:8070/profile也是同样的结果

5、将Git仓库中的microservice-foo-dev.properties文件内容修改为如下内容

```properties

profile=dev-1.0-bus

```

6、发送POST请求到其中一个Config Client实例的/bus/refresh端点，例如：

```properties

curl -X POST http://localhost:8060/bus/refresh

```

7、访问两个Config Client节点的/profile端点，发现两个节点都会返回dev-1.0-bus，说明配置内容已被更新。

另外，使用git仓库的WebHooks，即可轻松实现配置的自动刷新，这里就不再赘述。


### 自动刷新配置的架构改进

在前面的实事例中，通过请求某个微服务/bus/refresh端点的方式来实现配置刷新，但这种方式并不优雅。原因如下：

* 破坏了微服务的职责单一原则。业务微服务只应关注自身业务，不应该承担配置刷新的职责。
* 破坏了微服务个节点的对等性。
* 有一定的局限性。例如，微服务在迁移时，网络地址常常会发生变化。此时如果想自动刷新配置，就不得不修改WebHook的配置。

不妨改进一下架构，使用config server的/bus/refresh端点来刷新配置。这样，各个微服务只需要关注自身的业务，而不再承担配置刷新的职责，改进后的架构图如下：


![使用Spring Cloud Bus架构图-改进](http://f.lingjiatong.cn:30090/rootelement/articleQuote/%E4%BD%BF%E7%94%A8Spring%20Cloud%20Bus%E6%9E%B6%E6%9E%84%E5%9B%BE-%E6%94%B9%E8%BF%9B.png)


### Spring Cloud Config与Eureka配合使用

1、将Config Server和Config Client都注册到Eureka Server上。

2、Config Client的bootstrap.yml可配置如下

```yml

spring:
  application:
    name: microservice-config-client
  cloud:
    config:
      profile: dev
      label: master
      # 指定需要获取的配置的名字
      name: microservice-foo
      discovery:
        # 指定config service在服务发现中的serviceId，默认是configserver
        service-id: microservice-config-server
        enabled: true
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
management:
  security:
    enabled: false
eureka:
  instance:
    prefer-ip-address: true
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
    fetch-registry: true
    register-with-eureka: true

```


## 第十、十一、十二、十三、十四章

无学习必要，略过

