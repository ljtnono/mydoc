# gcc编译详解

## 编译流程图





## 环境

操作系统：MacOS
编译器：gcc-11.2.0

## 预处理-Pre-Processing

```bash

# -E 选项指示编译器仅对输入文件进行预处理
g++ -E test.cpp -o test.i 
// 预处理会生成.i文件

```

## 编译-Compiling

```bash

# -s 编译选项告诉g++在为c++代码产生了汇编语言文件后停止编译
# g++ 产生的汇编语言文件的缺省扩展名为 .s

g++ -S test.i -o test.s

```

## 汇编-Assembling

```bash

# -c 选项告诉g++ 仅把源代码编译为机器语言的目标代码
# 缺省时 g++ 建立的目标代码文件有一个 .o 的扩展名

g++ -c test.s -o test.o

```

## 链接-Linking

```bash

# -o 编译选项来为将产生的可执行文件用指定的文件名
g++ test.o -o test

```

## g++重要编译参数

### -g 编译带调试信息的可执行文件

```bash

# -g 选项告诉GCC产生能被GNU调试器GDB使用的调试信息，以调试程序
# 产生带调试信息的可执行文件test
g++ -g test.cpp -o test

```

### -O[n] 优化源代码

```bash

## 所谓优化，例如省略掉代码中从未使用过的变量，直接将常量表达式用结果值代替等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。

# -O 选项告诉g++对源代码进行基本优化。这些优化在大多数情况下都会使程序执行的更快。 -O2选项告诉g++产生尽可能小和尽可能快的代码。如-O2, -O3, -On(n 常为 0-3)

# -O 同时减小代码的长度和执行时间，其效果等价于-O1
# -O0 表示不做优化
# -O1 为默认优化
# -O2 除了完成-O1的优化之外，还进行一些额外的调整工作，如指令调整等。
# -O3 则包括循环展开和其他一些与处理特性相关的优化工作。


g++ -O2 test.cpp

```

### -l 和 -L 指定库文件 ｜ 指定库文件路径

```bash

# -l参数（小写）就是用来指定程序要链接的库，-l参数紧接着就是库名
# 在/lib/usr/lib和/usr/local/lib里的库直接用-l参数就能链接

# 链接glog库
g++ -lglog test.cpp

# 如果库文件没放在上面三个目录里，需要使用-L参数（大写）指定库文件所在目录
# -L参数跟着的是库文件所在的目录名

# 链接mytest库，libmytest.so在/User/lingjiatong/Desktop/mytest目录下
g++ -L/User/lingjiatong/Desktop/mytest -lmytest test.cpp

```

### -I 指定头文件搜索目录

```bash

# /usr/include 目录一般是不用指定的，gcc知道去哪里找，但是如果头文件不在/usr/include里，我们就要用-I参数指定了，比如头文件放在/Users/lingjiatong/Desktop/headers目录里，那编译命令行就要加上-I/Users/lingjiatong/Desktop/headers参数了，如果不加就会得到一个"xxx.h: No such file or directory"的错误。-I参数可以用相对路径，比如头文件在当前目录,可以用-I.指定。

g++ -I/Users/lingjiatong/Desktop/headers test.cpp

```

### -Wall 打印警告信息

```bash

# 打印出gcc提供的警告信息
g++ -Wall test.cpp

```

### -w 关闭警告信息

```bash

# 关闭所有警告信息
g++ -w test.cpp

```

### -std=c++11 设置编译标准

```bash

# 使用c++11标准编译test.cpp

g++ -std=c++11 test.cpp

```

### -o 指定输出文件名

```bash

g++ test.cpp -o test

```


## 静态库和动态库

* 静态库和动态库的载入时间是不一样的。
* 静态库的代码在编译的过程中已经载入到可执行文件中，所以最后生成的可执行文件相对较大。
* 动态库的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，所以最后生成的可执行文件相对较小。
* 静态库和动态库的最大区别是，静态库链接的时候把库直接加载到程序中,而动态库链接的时候，它只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度和降低程序的耦合度。
* 静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。
* 动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。
* 无论静态库，还是动态库，都是由.o文件创建的。因此，我们必须将源程序hello.c通过gcc先编译成.o文件。

